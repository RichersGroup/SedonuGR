PARAMETERS
===========================
[] indicates options
() indicates prerequisite

||================||
||INCLUDED PHYSICS||
||================||

do_visc = [0,1] add energy source to matter absorption
	representing viscous heating. Simply adds some amount of
        energy to each zone's e_abs immediately after particles are
        propagated. Only affects solving for temperature, does not
	directly affect neutrino emission rates.

visc_specific_heat_rate = [double>0] (do_visc==1) viscous
			heating per unit mass (erg/g/s)

do_annihilation = [0,1] compute annihilation rates based on
		integrating distribution functions over annihilation kernels.

reflect_outer = [0,1]
	      0 --> outflow outer boundary conditions
	      1 --> reflecting outer boundary conditions

use_scattering_kernels = [0,1] 1 uses full inelastic scattering formalism. 0 assumes
		       elastic, isotropic scattering and neglects the delta and
		       inelastic_phi* data in nulib files


||===================||
||EQUILIBRIUM SOLVING||
||===================||

equilibrium_T = [0,1] solve for T such that each zone emits the energy
	      it absorbs after each iteration

equilibrium_Ye = [0,1] solve for Ye such that the zone emits the
	       lepton number it absorbs after each iteration

equilibrium_damping = [0<float<1] changes in values between iterations
		    are decreased by this factor to stabilize the solve

equilibrium_itmax = [int>0] maximum number of iterations the
		  equilibrium solver can use

equilibrium_tolerance = [float>0] tolerance of the equilibrium solver


||======================||
||OPACITY AND EMISSIVITY||
||======================||

neutrino_type = ["NuLib","grey","Nagakura","GR1D"] defines how we obtain opacities

(neutrino_type=="grey")
grey_opac = [float>0] neutrino grey opacity (cm^2/g). If <=0, uses
	  NuLib table instead
grey_abs_frac = [0<float<1] probability of neutrino to be absorbed (rather than scattered)

(neutrino_type=="grey","Nagakura")
nugrid_n = [int>0] number of neutrino frequency bins
nugrid_start = [float>=0] (nugrid_n>0) bottom of the neutrino frequency grid (MeV)
nugrid_stop = [float>=0]  (nugrid_n>0) top of the neutrino frequency grid (MeV)
nugrid_filename = [string] (nugrid_n<=0) location of file with frequency coordinates

(neutrino_type=="NuLib","GR1D")
nulib_table = [string] (grey_opacity<0) path to the NuLib opacity table
nulib_eos = [string] path to the equation of state table - used in
	  some of the tests and to print chemical potentials in the
	  output. Value not used if compiled with Helmholtz EOS.

(neutrino_type=="Nagakura")
opacity_dir = [string] location of directory containing neutrino interaction rates


||==============||
||ESCAPE SPECTRA||
||==============||

spec_n_mu = [int>0] number of cos(theta) bins in the spectra

spec_n_phi = [int>0] number of phi bins in the spectra


||=====================||
||DISTRIBUTION FUNCTION||
||=====================||

distribution_type = ["Polar","Moments","RadialMoments","GR1D"]
		  "Polar" - discretized into theta and mu bins
		  "Moments" - discretized into the first four moments (0,1,2,3)
		  "RadialMoments" - moments, but non-vanishing terms in spherical symmetry
		  "GR1D" - RadialMoments, but with functionality for coupling w/ GR1D

distribution_nmu = [int>0] -- number of cos(theta) bins in every
        grid zone's distribution function.

distribution_nphi = [int>0] -- number of phi bins in every grid
        zone's distribution function.

distribution_mugrid_filename = [string] (distribution_nmu>0 && distribution_nphi>0)
			     location of file containing cos(polar_angle) coordinates
			     
distribution_phigrid_filename = [string]  (distribution_nmu>0 && distribution_nphi>0)
			     location of file containing azimuthal coordinates


||==============||
||GRID AND MODEL||
||==============||

grid_type = [string] which type of grid the input data is for
	  "Grid0DIsotropic" --> completely isotropic
	  "Grid1DSphere" --> 1D (spherical symmetry)
	  "Grid2DSphere" --> 2D (rotational symmetry)
	  "Grid2DCylinder" --> 2D (rotational symmetry)
	  "Grid3DCart" --> 3D (no symmetries) 

model_type = [string] which format is the model file in?
	   Grid2DSphere --> ["Nagakura","Flash","custom"]
	   Grid3DCart --> ["SpEC","THC"]

model_file = [string] path to the model file

(grid_type="Grid0DIsotropic")
Grid0DIsotropic_rho = [float>0] density in g/ccm
Grid0DIsotropic_T = [float>0] temperature in MeV
Grid0DIsotropic_Ye = [0<=float<=1] electron fraction

(grid_type="Grid1DSphere",model_type="Nagakura")
   Grid1DSphere_Nagakura_rgrid_file = [string] path to radial coordinates

(grid_type="Grid2DSphere",model_type="Nagakura")
   Grid2DSphere_Nagakura_rgrid_file = [string] path to radial coordinates
   Grid2DSphere_Nagakura_thetagrid_file = [string] path to theta coordinates

(grid_type="Grid2DSphere",model_type="Flash")
   Grid2DSphere_Flash_xCoords_file = [string] path to Flash x coordinates
   Grid2DSphere_Flash_yCoords_file = [string] path to Flash y coordinates

(grid_type="Grid3DCart")
   Grid3DCart_reflect_x = [0,1] reflection symmetry across x=0 plane?
   Grid3DCart_reflect_y = [0,1] reflection symmetry across y=0 plane?
   Grid3DCart_reflect_z = [0,1] reflection symmetry across z=0 plane?
   Grid3DCart_rotate_hemisphere_x = [0,1] hemispherical rotational
   				  symmetry with boundaries at x=0?
   Grid3DCart_rotate_hemisphere_y = [0,1] hemispherical rotational
   				  symmetry with boundaries at y=0?
   Grid3DCart_rotate_quadrant = [0,1] quadrant rotational symmetry
   			      with boundaries at x=0 and y=0?
   Grid3DCart_THC_reflevel = [int>0] (model_type="THC") read data from
   			   which THC refinement level


||======||
||OUTPUT||
||======||

write_zones_every = [int>0] write the fluid data every n iterations


||=================||
||PARTICLE CREATION||
||=================||

n_subcycles = [int>0] number of times to emit particles. Essentially
	    running the experiment many times rather than all at once
	    so a huge number of particles can be used without running
	    out of memory.

n_emit_core_per_bin = [int>=0] number of particles to emit from the
 		    core per species/energy bin during each emission
 		    stage
n_emit_therm_per_bin = [int>=0] number of particles to emit from cells
		     per energy/cell/species bin during each emission
		     stage


||============||
||INNER SOURCE||
||============||

r_core = [float>0] radius of inner emitting core (cm)

T_core = [float_array>0] temperature of the inner emitting core (K)

core_chem_pot = [float_array] chemical potential of each species emitted from core (MeV)

core_lum_multiplier = [float_array>0] amplify the natural Stefan-Boltzmann
		    blackbody core luminosity by this factor.


||================||
||GENERAL CONTROLS||
||================||

verbose = [0,1] Print detailed information to stdout?

max_n_iter = [int>=0] stop after this many iterations (1 iteration
	   is a emit-propagate-solve cycle)

max_time_hours = [float>0] maximum walltime. After this, sedonu will
	       stop iterating, but will finish current iteration

min_step_size = [float>0] minimum fraction of a zone length a particle is
	      allowed to travel before updating opacity information

max_step_size = [float>0] maximum fraction of a zone length a particle is
	      allowed to travel before updating opacity information

min_packet_weight = [float>0] minimum weight for a neutrino packet. Initial weight is 1.

||==========||
||RANDOMWALK||
||==========||

do_randomwalk = [0,1] in diffusive zones/bins use random walk approximation

randomwalk_max_x = [float>0] maximum dimensionless x from which to
		 sample diffusion time. 1.0 should be plenty.

randomwalk_sumN = [int>1] number of terms in the sum to evaluate the
		diffusion time PDF during initialization. 1000 is far
		more than necessary but does not affect run time

randomwalk_npoints = [int>1] number of points in the diffusion time PDF

randomwalk_interpolation_order = [0,1,3] interpolation order used when
			       sampling the diffusion time CDF

randomwalk_min_optical_depth = [float>=0] optical depth below which
			     the random walk approximation is
			     considered invalid and will not evaluate
			     (resort to isotropic scattering instead)
